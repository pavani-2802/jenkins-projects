pipeline {
  agent {
    docker {
      image 'my-maven-docker:latest'
      args '--user root -v /var/run/docker.sock:/var/run/docker.sock -e DOCKER_API_VERSION=1.41'
    }
  }

  environment {
    // change these to match your setup
    DOCKER_CRED_ID = 'docker-cred'
    SONAR_CRED_ID  = 'sonarqube'
    GITHUB_CRED_ID = 'github'
    GIT_USER_NAME  = 'pavani-2802'
    GIT_USER_EMAIL = 'pavanikethari.28@gmail.com'

    // application paths and image
    APP_DIR   = 'java-maven-sonar-argocd-helm-k8s/spring-boot-app'
    POM_PATH  = "${APP_DIR}/pom.xml"
    DEPLOY_FILE = 'java-maven-sonar-argocd-helm-k8s/spring-boot-app-manifests/deployment.yml'
    IMAGE_NAME = "pavanif5/jenkins-projects"
    DOCKER_IMAGE = "${IMAGE_NAME}:${BUILD_NUMBER}"
    SONAR_URL = "http://192.168.41.130:9000"
    GIT_BRANCH = 'main'

  stages {

    stage('Checkout') {
      steps {
        // uncomment next line if you want Jenkins to do an explicit git checkout
        // git branch: "${GIT_BRANCH}", url: "https://github.com/${GIT_USER_NAME}/jenkins-projects.git"
        echo 'Checkout stage (workspace already provided by multibranch or job)'
        sh 'ls -la'
      }
    }

    stage('Prepare workspace') {
      steps {
        sh '''#!/bin/bash
          set -euo pipefail
          echo "[PREP] Remove stale sonar output (avoid mvn clean failure)"
          rm -rf "${WORKSPACE}/${APP_DIR}/target/sonar" || true
          echo "[PREP] Ensure workspace permissions (best-effort)"
          chown -R $(id -u):$(id -g) "${WORKSPACE}" >/dev/null 2>&1 || true
          chmod -R u+rwX "${WORKSPACE}" || true
        '''
      }
    }

    stage('Build and Test') {
      steps {
        sh '''#!/bin/bash
          set -euo pipefail
          echo "[BUILD] Listing current directory"
          ls -ltra
          echo "[BUILD] Running mvn clean package"
          mvn -B -f "${POM_PATH}" clean package
        '''
      }
    }

    stage('Static Code Analysis') {
      steps {
        withCredentials([string(credentialsId: env.SONAR_CRED_ID, variable: 'SONAR_AUTH_TOKEN')]) {
          sh '''#!/bin/bash
            set -euo pipefail
            echo "[SONAR] Removing stale sonar folder before analysis"
            rm -rf "${WORKSPACE}/${APP_DIR}/target/sonar" || true
            echo "[SONAR] Running sonar:sonar"
            mvn -B -f "${POM_PATH}" sonar:sonar -Dsonar.login="${SONAR_AUTH_TOKEN}" -Dsonar.host.url="${SONAR_URL}"
          '''
        }
      }
    }

    stage('Build & Push Docker Image') {
      steps {
        script {
          // Build image
          sh '''#!/bin/bash
            set -euo pipefail
            echo "[DOCKER] docker version (client/server):"
            docker version --format 'Client: {{.Client.Version}} (API: {{.Client.APIVersion}}) | Server: {{.Server.Version}} (API: {{.Server.APIVersion}})' || true
            echo "[DOCKER] Building image ${DOCKER_IMAGE} from ${APP_DIR}"
            docker build -t "${DOCKER_IMAGE}" -f "${APP_DIR}/Dockerfile" "${APP_DIR}"
          '''

          // Login & push using credentials securely
          withCredentials([usernamePassword(credentialsId: env.DOCKER_CRED_ID, usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
            sh '''#!/bin/bash
              set -euo pipefail
              export DOCKER_API_VERSION=${DOCKER_API_VERSION:-1.41}
              echo "[DOCKER] Logging in to Docker Hub (secure)"
              echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin https://index.docker.io/v1/

              echo "[DOCKER] Pushing ${DOCKER_IMAGE}"
              docker push "${DOCKER_IMAGE}"

              repo="${DOCKER_IMAGE%:*}"
              echo "[DOCKER] Tagging latest: ${repo}:latest"
              docker tag "${DOCKER_IMAGE}" "${repo}:latest" || true
              docker push "${repo}:latest" || true
            '''
          }
        }
      }
    }

    stage('Update Deployment File') {
      steps {
        withCredentials([string(credentialsId: env.GITHUB_CRED_ID, variable: 'GITHUB_TOKEN')]) {
          sh '''#!/bin/bash
            set -euo pipefail
            echo "[GIT] Configure git user"
            git config user.email "${GIT_USER_EMAIL}"
            git config user.name "${GIT_USER_NAME}"

            # Ensure branch exists and is up-to-date
            git fetch origin || true
            if git rev-parse --verify "${GIT_BRANCH}" >/dev/null 2>&1; then
              git checkout "${GIT_BRANCH}"
              git pull origin "${GIT_BRANCH}" || true
            else
              git checkout -b "${GIT_BRANCH}"
            fi

            # Ensure deploy file exists
            if [ ! -f "${DEPLOY_FILE}" ]; then
              echo "[GIT][ERROR] Deploy file not found: ${DEPLOY_FILE}"
              ls -la "$(dirname "${DEPLOY_FILE}")" || true
              exit 1
            fi

            echo "[GIT] Updating deploy file with build number ${BUILD_NUMBER}"
            sed -i "s/replaceImageTag/${BUILD_NUMBER}/g" "${DEPLOY_FILE}"

            if git diff --quiet -- "${DEPLOY_FILE}"; then
              echo "[GIT] No changes detected; skipping commit/push"
            else
              git add "${DEPLOY_FILE}"
              git commit -m "Update deployment image to version ${BUILD_NUMBER}"

              REMOTE_URL="https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/jenkins-projects.git"
              echo "[GIT] Setting remote to token-authenticated URL (hidden)"
              git remote set-url origin "${REMOTE_URL}" || git remote add origin "${REMOTE_URL}"

              echo "[GIT] Pushing changes to ${GIT_BRANCH}"
              git push origin HEAD:${GIT_BRANCH} --follow-tags
            fi
          '''
        }
      }
      post {
        failure {
          sh '''#!/bin/bash
            echo "[GIT][DIAG] git status:"
            git status --porcelain -b || true
            echo "[GIT][DIAG] git remote -v:"
            git remote -v || true
            echo "[GIT][DIAG] last commit:"
            git --no-pager log -1 --pretty=fuller || true
          '''
        }
      }
    }

  } // stages

  post {
    always {
      echo "Showing target directory content for debugging (if exists)"
      sh 'ls -la "${WORKSPACE}/${APP_DIR}/target" || true'
    }
    failure {
      echo "Build failed â€” see logs above for cause"
    }
  }
}
